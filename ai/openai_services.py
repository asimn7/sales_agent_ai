"""
This is a complex piece of code designed to manage a real-time, 
two-way voice conversation between a caller (via Twilio Media Streams)
and an AI (via a hypothetical OpenAI Realtime WebSocket API).

Overall Purpose:

The RealtimeOpenAIHandler class acts as a sophisticated orchestrator for a single
phone call (call_sid). It manages two WebSocket connections simultaneously:

Twilio WebSocket (self.twilio_ws): Receives incoming audio stream events 
from the caller via Twilio. It also sends outgoing audio generated by the 
AI back to Twilio to be played to the caller.

OpenAI WebSocket (self.openai_ws): Sends the caller's audio to OpenAI 
for processing (speech-to-text, AI response generation, text-to-speech). 
It receives back audio deltas (chunks) from the AI and other events like
transcripts and speech activity signals.

The handler manages the state of the interaction, handles setup/teardown, 
deals with interruptions (barge-in), processes transcripts to potentially trigger 
actions (like info extraction or saving data), and interacts with the database 
for context and data storage."""

import asyncio
import json
import base64
import websockets
from websockets.exceptions import ConnectionClosed, ConnectionClosedOK
from sqlalchemy.orm import Session
from typing import Optional

from config import settings, logger
from database import crud
from services import info_extraction, notification_service # Import necessary services
from .prompts import generate_openai_instructions # Import prompt generator

class RealtimeOpenAIHandler:
    """Handles a single WebSocket connection for real-time AI interaction."""

    def __init__(self, websocket, db_session_factory, call_sid: str, phone_number: str):
        self.twilio_ws = websocket
        self.db_session_factory = db_session_factory # Pass factory to create sessions within tasks
        self.call_sid = call_sid
        self.phone_number = phone_number
        self.openai_ws = None
        self.stream_sid: Optional[str] = None # Learned from 'start' event
        self.latest_media_timestamp: int = 0
        self.last_assistant_item_id: Optional[str] = None
        self.response_start_timestamp_twilio: Optional[int] = None
        self.mark_queue = []
        self._is_running = False
        self.temp_name_email_storage = {"name": None, "email": None} # State specific to this call

    async def _connect_openai(self):
        """Establishes connection to OpenAI Realtime API."""
        try:
            self.openai_ws = await websockets.connect(
                f'wss://api.openai.com/v1/realtime?model={settings.OPENAI_REALTIME_MODEL}',
                extra_headers={
                    "Authorization": f"Bearer {settings.OPENAI_API_KEY}",
                    "OpenAI-Beta": "realtime=v1"
                }
            )
            logger.info(f"[{self.call_sid}] OpenAI WebSocket connected.")
            await self._send_session_update()
        except Exception as e:
            logger.error(f"[{self.call_sid}] Failed to connect to OpenAI WebSocket: {e}")
            raise

    async def _send_session_update(self):
        """Sends session configuration to OpenAI."""
        if not self.openai_ws: return

        with self.db_session_factory() as db: # Create a session for this operation
            instructions, is_returning = generate_openai_instructions(db, self.phone_number)

        session_update = {
            "type": "session.update",
            "session": {
                "turn_detection": {"type": "server_vad"},
                "input_audio_format": "g711_ulaw",
                "output_audio_format": "g711_ulaw",
                "voice": settings.AI_VOICE,
                "instructions": instructions,
                "modalities": ["text", "audio"],
                "temperature": 0.8,
            }
        }
        logger.debug(f"[{self.call_sid}] Sending session update to OpenAI: {json.dumps(session_update)}")
        await self.openai_ws.send(json.dumps(session_update))
        # Optionally send initial conversation item if needed (logic from original code)
        # await self._send_initial_conversation_item(is_returning)
        # Trigger initial response if AI speaks first
        await self.openai_ws.send(json.dumps({"type": "response.create"}))

    async def _receive_from_twilio(self):
        """Listens for messages from Twilio and forwards audio to OpenAI."""
        try:
            async for message in self.twilio_ws.iter_text():
                if not self._is_running: break
                data = json.loads(message)
                event = data.get('event')

                if event == 'start':
                    self.stream_sid = data['start']['streamSid']
                    # We already have call_sid and phone_number from initialization
                    logger.info(f"[{self.call_sid}] Twilio stream started: {self.stream_sid}")
                    # Reset state variables related to response timing for the new stream
                    self.response_start_timestamp_twilio = None
                    self.latest_media_timestamp = 0
                    self.last_assistant_item_id = None

                elif event == 'media' and self.openai_ws and self.openai_ws.open:
                    if not self.stream_sid: continue # Wait for start event
                    self.latest_media_timestamp = int(data['media']['timestamp'])
                    audio_payload = data['media']['payload']
                    audio_append = {"type": "input_audio_buffer.append", "audio": audio_payload}
                    await self.openai_ws.send(json.dumps(audio_append))

                elif event == 'mark':
                    if self.mark_queue: self.mark_queue.pop(0)

                elif event == 'stop':
                     logger.info(f"[{self.call_sid}] Twilio stream stopped.")
                     # Consider closing OpenAI connection here or let handler manage lifecycle
                     break # Exit loop on stop

        except (ConnectionClosed, ConnectionClosedOK):
            logger.info(f"[{self.call_sid}] Twilio WebSocket connection closed.")
        except Exception as e:
            logger.error(f"[{self.call_sid}] Error in receive_from_twilio: {e}")
        finally:
             await self.stop() # Ensure cleanup on exit


    async def _send_to_twilio(self):
        """Listens for messages from OpenAI and forwards audio/handles events."""
        if not self.openai_ws: return
        try:
            async for message in self.openai_ws:
                if not self._is_running: break
                response = json.loads(message)
                response_type = response.get('type')

                if response_type in settings.LOG_EVENT_TYPES:
                    logger.info(f"[{self.call_sid}] OpenAI Event: {response_type}")
                    # logger.debug(f"[{self.call_sid}] OpenAI Data: {response}") # More verbose

                if response_type == 'response.audio.delta' and 'delta' in response:
                    if not self.stream_sid: continue
                    audio_payload = base64.b64encode(base64.b64decode(response['delta'])).decode('utf-8')
                    media_message = {
                        "event": "media",
                        "streamSid": self.stream_sid,
                        "media": {"payload": audio_payload}
                    }
                    await self.twilio_ws.send(json.dumps(media_message))

                    if self.response_start_timestamp_twilio is None:
                        self.response_start_timestamp_twilio = self.latest_media_timestamp
                    if response.get('item_id'):
                         self.last_assistant_item_id = response['item_id']
                    await self._send_mark() # Send mark after sending audio

                elif response_type == 'input_audio_buffer.speech_started':
                    await self._handle_interruption()

                elif response_type == 'response.done':
                    await self._process_response_done(response)

        except (ConnectionClosed, ConnectionClosedOK):
            logger.info(f"[{self.call_sid}] OpenAI WebSocket connection closed.")
        except Exception as e:
            logger.error(f"[{self.call_sid}] Error in send_to_twilio: {e}")
        finally:
            await self.stop() # Ensure cleanup on exit

    async def _send_mark(self):
        """Sends a mark message to Twilio."""
        if self.stream_sid and self.twilio_ws.open:
            mark_event = {
                "event": "mark",
                "streamSid": self.stream_sid,
                "mark": {"name": f"ai_response_{len(self.mark_queue)}"}
            }
            await self.twilio_ws.send(json.dumps(mark_event))
            self.mark_queue.append(mark_event["mark"]["name"])

    async def _handle_interruption(self):
        """Handles barge-in/interruption when user speech starts."""
        logger.info(f"[{self.call_sid}] Handling interruption.")
        if self.mark_queue and self.response_start_timestamp_twilio is not None and self.last_assistant_item_id:
            elapsed_time = self.latest_media_timestamp - self.response_start_timestamp_twilio
            if elapsed_time < 0: elapsed_time = 0 # Ensure non-negative

            logger.info(f"[{self.call_sid}] Truncating item {self.last_assistant_item_id} at {elapsed_time}ms")
            truncate_event = {
                "type": "conversation.item.truncate",
                "item_id": self.last_assistant_item_id,
                "content_index": 0,
                "audio_end_ms": elapsed_time
            }
            if self.openai_ws and self.openai_ws.open:
                await self.openai_ws.send(json.dumps(truncate_event))

            # Clear Twilio's outbound buffer
            if self.stream_sid and self.twilio_ws.open:
                await self.twilio_ws.send(json.dumps({"event": "clear", "streamSid": self.stream_sid}))

            # Reset state
            self.mark_queue.clear()
            self.last_assistant_item_id = None
            self.response_start_timestamp_twilio = None

    async def _process_response_done(self, response: dict):
        """Processes the full transcript when OpenAI finishes a response chunk."""
        output = response.get('response', {}).get('output', [])
        if not output: return

        content = output[0].get('content', [])
        full_transcript = ""
        for item in content:
            if item.get('type') == 'audio' and 'transcript' in item:
                transcript_part = item['transcript']
                full_transcript += transcript_part + " "

                # --- Actions based on transcript ---
                # 1. Check for Demo Request
                if any(phrase in transcript_part.lower() for phrase in ["need demo", "want demo", "show me demo"]):
                    logger.info(f"[{self.call_sid}] Demo requested in transcript.")
                    # Assuming schedule_demo is async and available
                    # await notification_service.schedule_demo(...) # Pass necessary details

                # 2. Extract Name/Email (Consider doing this on the full_transcript once)
                name, email = await info_extraction.extract_name_and_email_from_text(transcript_part)
                if name: self.temp_name_email_storage["name"] = name
                if email: self.temp_name_email_storage["email"] = email


        if full_transcript.strip():
             logger.info(f"[{self.call_sid}] Full transcript segment: {full_transcript.strip()}")
             # 3. Save Conversation (Consider saving at end of call instead of every turn?)
             # This requires getting the current system message potentially
             with self.db_session_factory() as db:
                 # instructions, _ = generate_openai_instructions(db, self.phone_number) # Get instructions again
                 # crud.save_conversation(db, self.phone_number, full_transcript.strip(), instructions)
                 pass # Decide on save strategy

             # 4. Update Personal Info if Name & Email collected
             collected_name = self.temp_name_email_storage["name"]
             collected_email = self.temp_name_email_storage["email"]
             if collected_name and collected_email:
                 logger.info(f"[{self.call_sid}] Both name ({collected_name}) and email ({collected_email}) collected. Updating DB.")
                 with self.db_session_factory() as db:
                     updated = crud.update_personal_info(db, self.phone_number, collected_name, collected_email)
                     if updated:
                          logger.info(f"[{self.call_sid}] Personal info updated in DB.")
                          # Reset temporary storage after successful update
                          self.temp_name_email_storage = {"name": None, "email": None}


    async def start(self):
        """Starts the handler by connecting to OpenAI and running listeners."""
        if self._is_running: return
        self._is_running = True
        logger.info(f"[{self.call_sid}] Starting RealtimeOpenAIHandler.")
        try:
            await self._connect_openai()
            # Run listeners concurrently
            await asyncio.gather(
                self._receive_from_twilio(),
                self._send_to_twilio()
            )
        except Exception as e:
             logger.error(f"[{self.call_sid}] Error during handler execution: {e}")
        finally:
             logger.info(f"[{self.call_sid}] Handler process ended.")
             await self.stop() # Ensure cleanup

    async def stop(self):
        """Stops the handler and closes connections."""
        if not self._is_running: return
        self._is_running = False
        logger.info(f"[{self.call_sid}] Stopping RealtimeOpenAIHandler.")
        # Close OpenAI WebSocket
        if self.openai_ws and self.openai_ws.open:
            await self.openai_ws.close()
            logger.info(f"[{self.call_sid}] OpenAI WebSocket closed.")
        # Twilio WebSocket closing is handled by FastAPI/caller